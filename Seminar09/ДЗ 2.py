# Посчитать коэффициент линейной регрессии при заработной плате (zp), используя градиентный спуск (без intercept).

import numpy as np

zp = np.array([35, 45, 190, 200, 40, 70, 54, 150, 120, 110])
ks = np.array([401, 574, 874, 919, 459, 739, 653, 902, 746, 832])
n = ks.size
alpha = 1e-6

B1 = 0.1
for i in range(5):
    B1 -= alpha * (2 / n) * np.sum((B1 * zp - ks) * zp)
    print("B1 = {}".format(B1))
# B1 = 0.25952808
# B1 = 0.414660650906144
# B1 = 0.5655188230595969
# B1 = 0.7122203698240712
# B1 = 0.8548798195302346

B1 = 0.1
for i in range(1000):
    B1 -= alpha * (2 / n) * np.sum((B1 * zp - ks) * zp)
    if i % 200 == 0:
        print('Итерация = {i}, B1 = {B1}, mse = {mse}'.format(i=i, B1=B1, mse=(np.sum((B1 * zp - ks) ** 2) / n)))
# iteration = 0, B1 = 0.25952808, mse = 493237.7212546963
# iteration = 200, B1 = 5.868748638669329, mse = 56522.97550129376
# iteration = 400, B1 = 5.8897415574471985, mse = 56516.85850140053
# iteration = 600, B1 = 5.889820124983314, mse = 56516.85841572062
# iteration = 800, B1 = 5.88982041902807, mse = 56516.8584157194

y_pred = B1 * zp
print(f'Прогназируемое значение y = {y_pred}')
# [ 206.1437147   265.04191891 1119.06587983 1177.96408403  235.59281681 412.28742941  318.05030269  883.47306302  706.77845042  647.88024621]
print(f'Функция потерь mse = {np.sum((B1 * zp - ks) ** 2) / n}')
# 56516.85841571943